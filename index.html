<!DOCTYPE html>
<html ng-app="MFCCountdown">
<head>
    <title>MFC Countdown</title>

    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css"/>
    <style type="text/css">
        .css-form input.ng-invalid.ng-dirty {
            background-color: #FA787E;
        }

        .css-form input.ng-valid.ng-dirty {
            background-color: #78FA89;
        }
        th
        {
            font-size:larger;
            text-align:center !important;
            background-color: #eaeaea;
            background-image: -moz-linear-gradient(#fafafa, #eaeaea);
            background-image: -webkit-linear-gradient(#fafafa, #eaeaea);
            background-image: linear-gradient(#fafafa, #eaeaea);
        }
    </style>
    <script src="js/shims.js"></script>
    <script src="js/lib/jquery-1.9.1.min.js"></script>
    <script src="js/lib/angular.min.js"></script>
    <script src="js/lib/bootstrap.min.js"></script>
    <script src="js/lib/ui-bootstrap-custom-tpls-0.3.0-SNAPSHOT.min.js"></script>
    <script src="js/lib/keypress.js"></script>
</head>
<body ng-controller="CountdownCtrl">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="brand">MFC Countdown <span ng-show="model != undefined">:: {{model.name}}</span></div>
            <button class="btn" ng-click="showCountdownModal = true" ng-show="model != undefined && !countdownActive">Set Countdown</button>
            <button class="btn" ng-click="showTipsModal = true" ng-show="tips.length > 0">Tips</button>
            <button class="btn" ng-click="showSelectModel = true" >{{(model == undefined) && 'Select' || 'Change'}} Model</button>
            <div class="pull-right">
                <button class="btn" ng-click="showAboutModal = true">About</button>
            </div>
       </div>
    </div>

    <div class="container-fluid">
        <alert ng-repeat="alert in alerts" type="alert.type" close="closeAlert($index)">{{alert.msg}}</alert>
        <div class="row-fluid">
            <div class="span12">
                <div ng-show="countDownDisplayText" class="hero-unit" style="font-size:100px; font-weight: bold; text-align: center">{{countDownDisplayText}}</div>
            </div>
        </div>
    </div>

    <div modal="showSelectModel" close="showSelectModel = false" options="opts" ng-cloak>
        <div class="modal-header">
            <h4>Enter Model name</h4>
        </div>
        <div class="modal-body">
            <input type="text" ng-model="modelName" autofocus ui-keypress="{13:'selectModel()'}" select-on-focus/>
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary cancel" ng-click="selectModel()">Select</button>
        </div>
    </div>

    <div modal="showCountdownModal" close="showCountdownModal = false" options="opts" ng-cloak>
        <form name="formCountdown" novalidate class="css-form">
            <div class="modal-header">
                <h4>Enter Countdown Amount</h4>
            </div>
            <div class="modal-body">
                <input type="number" min="1" required ng-model="countDownAmount" name="countDownAmount" autofocus ui-keypress="{13:'setCountdown()'}" select-on-focus/>
            </div>
            <div class="modal-footer">
                <button type="submit" class="btn btn-primary cancel" ng-disabled="formCountdown.$invalid" ng-click="setCountdown()">Set</button>
            </div>
        </form>
    </div>

    <div modal="showTipsModal" close="showTipsModal = false" options="opts" ng-cloak>
        <div class="modal-header">
            <div class="form-inline">
                Filter by Name: <input type="text" ng-model="search.Name" class="input-medium"/>
                By Amount: <input type="text" ng-model="search.Amount" class="input-medium"/>
            </div>
        </div>
        <div class="modal-body">
            <table class="table table-condensed table-bordered">
                <tr>
                    <th></th>
                    <th style="text-align:center">From</th>
                    <th style="text-align:center">Amount</th>
                    <th style="text-align:center">Countdown After Tip</th>
                </tr>
                <tr ng-repeat="tip in tips | filter: search">
                    <td style="text-align:center"><button class="btn btn-mini btn-danger" ng-click="removeTip(tip)"><icon class="icon icon-white icon-remove"></icon></button></td>
                    <td>{{tip.Name}}</td>
                    <td style="text-align:center">{{tip.Amount}}</td>
                    <td style="text-align:center">{{runningTotal($index)}}</td>
                </tr>
            </table>
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary cancel" ng-click="showTipsModal = false">OK</button>
        </div>
    </div>

    <div modal="showAboutModal" close="showAboutModal = false" options="opts" ng-cloak>
        <div class="modal-header">
            <h4>About MFC Countdown</h4>
        </div>
        <div class="modal-body">
            MFC Countdown assists with tracking countdowns in public rooms on myfreecams.com.
            It works by logging into the selected model's public room as a guest and making
            note of tips during the countdown.  Because it is logging in as a guest, <em>MFC Countdown
            can only track public tips.</em>  Anonymous tips will be included (if they are also public),
            but any tip not displayed in the public room of the model will not be counted.
            <br/><br/>
            Operation should be pretty simple.
            <br/>
            <ul>
                <li>Select a model by entering her name after clicking <span class="label">Select/Change Model</span></li>
                <li>Begin a countdown by entering an amount after clicking <span class="label">Set Countdown</span></li>
            </ul>
            MFC Countdown will display the amount remaining in the countdown until it is finished,
            at which point, it will display that the countdown is complete.  The countdown can be
            adjusted by entering selecting <span class="label">Set Countdown</span> again.
            <br/><br/>
            <strong>Planned enhancements:</strong>
            <br/>
            <ul>
                <li>Firefox support.</li>
            </ul>

        </div>
        <div class="modal-footer">
            <button class="btn btn-primary cancel" ng-click="showAboutModal = false">Ok</button>
        </div>
    </div>

    <script src="js/MFCCountdown.js"></script>
    <script src="js/MFCEnum.js"></script>
    <script src="js/MFCMessage.js"></script>
    <script src="js/MFCSocket.js"></script>
    <script src="js/directives.js"></script>
    <script>


        app.controller("CountdownCtrl", function CountdownCtrl($scope, Model, Countdown, Socket){
            //set the model to a stored model if there is one
            var model = Model.getModel();
            if (model && model.name != undefined) {
                $scope.modelName = model.name;
                $scope.model = model;
                lookupModel();
            }

            //select model modal stuff
            $scope.showSelectModel = false;
            $scope.selectModel = function() {
                $scope.alerts = [];
                lookupModel();
                Countdown.cancel();
            };

            function lookupModel(){
                Model.lookupModel($scope.modelName).then(function(model){
                    $scope.model = model;
                    updateCountdownDisplay();
                }, function(reason){
                    addAlert("error", reason);
                });
                $scope.showSelectModel = false;
            }

            //countdown tracking
            $scope.showCountdownModal = false;

            $scope.setCountdown = function(){
                if ($scope.formCountdown.$invalid)
                    return;
                $scope.alerts = [];
                $scope.showCountdownModal = false;
                Countdown.start(Model.getModel(), $scope.countDownAmount);
                updateCountdownDisplay();

            };

            function updateCountdownDisplay(){
                if (Countdown.active() && Countdown.current() > 0)
                    $scope.countDownDisplayText = Countdown.current();
                else
                    if (Countdown.amount() > 0)
                        $scope.countDownDisplayText = "Complete!";
                    else
                        $scope.countDownDisplayText = "";
            }


            $scope.$watch(function(){return Countdown.tips();}, function(tips){
                $scope.tips = tips;

                updateCountdownDisplay();
            }, true);


            //This is probably not the best way to do this,
            //calculating the sum every single tip, but its
            //working for now.
            $scope.runningTotal = function(index){
                var t = $scope.tips.slice(0, index + 1).reduce(function(total, tip){
                    return total + parseInt(tip.Amount,10);
                },0);
                return Countdown.amount() - t;
            };

            $scope.removeTip = function(tip){
                Countdown.removeTip(tip);
            };


            //alert stuff
            $scope.alerts = [];
            function addAlert(type, msg) {
                $scope.alerts.push({type: type, msg: msg});
            };
            $scope.closeAlert = function(index) {
                $scope.alerts.splice(index, 1);
            };

            Socket.listen("close", function(msg){
                addAlert("error", msg);
                console.log(msg);
            });

            Socket.listen("error", function(err){
                addAlert("error", err);
                console.log(err);
            });
        });

        app.factory("Socket", function(){
            return MFCSocket;
        });
        app.factory("Model", function($rootScope, $q, Socket){
            var LOCAL_STORAGE_ID = "mfccModel",
                 modelString = localStorage[LOCAL_STORAGE_ID];

            var model = modelString ? JSON.parse(modelString) : {
                name: undefined,
                broadcasterId: undefined
            };

            $rootScope.$watch(function(){ return model;}, function(){
                localStorage[LOCAL_STORAGE_ID] = JSON.stringify(model);
            });

            function modelLookupByName(modelName) {
                var deferred =  $q.defer();

                function scanUserLookup(msg) {
                    //only process userlookups
                    if (msg.Type !== MFCMessageType.FCTYPE_USERNAMELOOKUP)
                        return;

                    //we have a userlookup message, remove the listener
                    Socket.removeListener("message", scanUserLookup);

                    //check if the model was found
                    if (1 == msg.Arg2){
                        $rootScope.$apply(function(){
                            deferred.reject("Could not find {0}.".format(modelName));
                        });
                        return;
                    }

                    //model was found, check the video state
                    if (MFCVideoState.FCVIDEO_TX_IDLE != msg.Data.vs){
                        $rootScope.$apply(function(){
                            deferred.reject("{0} is not in public chat.".format(modelName));
                        });
                        return;
                    }

                    $rootScope.$apply(function(){
                        model = {
                            name: modelName,
                            broadcasterId: 100000000 + parseInt(msg.Arg2, 10)
                        };
                        deferred.resolve(model);
                    });
                };

                Socket.listen("message", scanUserLookup);

                Socket.send(new MFCMessage({
                    Type: MFCMessageType.FCTYPE_USERNAMELOOKUP,
                    From: 0,
                    To: 0,
                    Arg1: 20,
                    Arg2: 0,
                    Data: modelName
                }));

                return deferred.promise;
            }

            return {
                 getModel: function() {return model;},
                 lookupModel: modelLookupByName
            }
        });
        app.factory("Countdown", function($rootScope, Socket){
            var LOCAL_STORAGE_ID = "mfccCountdown",
                    countDownString = localStorage[LOCAL_STORAGE_ID];

            var emptyCountdown = {
                model: undefined,
                tips:[],
                amt: 0,
                complete: true
            };

            var countDown = countDownString ? JSON.parse(countDownString) : emptyCountdown;

            $rootScope.$watch(function(){ return countDown;}, function(){
                localStorage[LOCAL_STORAGE_ID] = JSON.stringify(countDown);
            }, true);

            var tipRegex = /(\w*) has tipped (\w*) (\d*) tokens/;

            //start up the countdown listener if there is an active
            //countdown that isn't complete
            if (undefined != countDown.complete && !countDown.complete)
                listenForTips();

            function currentTotal(){
                return countDown.tips.reduce(function(total, tip){
                    return total - tip.Amount;
                }, countDown.amt);
            }

            function completeCountdown() {
                countDown.complete = true;
                Socket.removeListener("message", parseTips);
            }

            function cancelCountdown(){
                countDown = emptyCountdown;
                Socket.removeListener("message", parseTips);
            }

            function parseTips(msg){
                if (msg.Type !== MFCMessageType.FCTYPE_CMESG)
                    return;

                //tips messages do not come from anybody
                if (msg.Arg1 != 0 || msg.Arg2 != 0 || msg.From != 0 || msg.To != countDown.model.broadcasterId)
                    return;

                var tipMsg = msg.Data.msg;

                var match = tipRegex.exec(tipMsg);
                if (match){
                    $rootScope.$apply(function(){
                        countDown.tips.push({Name: match[1], Amount: match[3]});
                    });

                    if (currentTotal() < 0)
                        completeCountdown();
                }
            }

            function listenForTips(){
                if (!Socket.loggedIn()){
                    setTimeout(listenForTips, 500);
                    return;
                }

                Socket.listen("message", parseTips);
                Socket.send(new MFCMessage({
                    Type: MFCMessageType.FCTYPE_JOINCHAN,
                    From: Socket.getSessionId(),
                    To: 0,
                    Arg1: countDown.model.broadcasterId,
                    Arg2: MFCChatOpt.FCCHAN_JOIN
                }));
            }

            function startCountdown(model, amount){
                countDown = {
                    amt: amount,
                    model: model,
                    tips: [],
                    complete: false
                };

                listenForTips();
            }

            function removeTip(tip){
                countDown.tips.splice(countDown.tips.indexOf(tip), 1);
                if (currentTotal() < countDown.amt)
                    countDown.complete = false;
            }

            return {
                start: startCountdown,
                cancel: cancelCountdown,
                resume: listenForTips,
                active: function(){
                    return !countDown.complete;
                },
                current: currentTotal,
                tips: function(){
                    return countDown.tips;
                },
                amount: function(){
                    return countDown.amt;
                },
                removeTip: removeTip
           }

        });
    </script>
</body>
</html>